---
layout: post
title: Atomic Kotlin (3)
date: 2024-02-20 14:36 +0900
image:
  path:
  alt:
categories: [📖BOOK]
tags: [
  kotlin,
    atomic-kotlin,
    독서]
---


아토믹 코틀린을 읽으며 알게 된 내용 정리하기 3

## 3부. 사용성

### 30. 확장 함수
> 라이브러리 커스터마이징 하기

코틀린 확장 함수는 기존 클래스에 멤버 함수를 추가하는 것과 같은 효과를 낸다.
하지만 수신 객체 타입 (확장 대상 타입)의 public 프로퍼티에만 접근 가능하다. 따라서 확장함수를 사용하는 이유는 this를 사용 또는 생략함으로써 구문적 편의를 얻기 위해 사용한다.


### 31. 이름 붙은 인자와 디폴트 인자
> 함수를 호출하며 인자의 이름을 지정 가능함
- 인자 순서를 변경하면 목록의 나머지 부분에서도 이름 붙은 인자를 사용해야 한다
- 디폴트 값이 있는 인자를 생략하고 인자에 이름을 붙여라. 가독성이 좋아진다.

**trailing comma**
- 마지막 파라미터 뒤에 콤마를 추가로 붙인 것
- 콤마를 추가하거나 빼지 않아도 새로운 아이템을 추가하거나 아이템의 순서를 바꿀 수 있음
- 코드 리뷰 시 1줄만 수정할 수 있어서 좋다!
```kotlin
class Color(
  val red: Int = 0,
  val green: Int = 0,
  val blue: Int = 0,
)
```

## 32. 오버로딩

피라미터 목록이 여러 다른 함수에 같은 이름을 사용

## 34. Enum class
 >이넘은 인스턴스 개수가 미리 정해져있고 클래스 본문 안에 모든 인스턴스가 나열되어 있는 특별한 종류의 클래스다.

enum class에 멤버 함수나 프로퍼티를 정의 가능함. 
마지막 이넘 값 다음에 세미콜론 추가한 후 포함시키기
```kotlin
enum class Direction(val notation: String){
  North("N"), South("S"), .. West("W");
  
  val opposite: Direction
    get() = when(this){
      North -> South
      ...
    }
}
```
notation : 인스턴스 값에 따라 다른 값 저장 가능. 


### 35. Data class

- toString() 자동 생성
- 같은 데이터를 포함하면 같은 결과가 나오도록 equals 자동 생성
- copy() : 현재 객체의 모든 데이터를 포함하는 새로운 객체 생성. 몇몇 값 새로 지정 가능

- HashMap과 HashSet에 넣을 때 키로 사용할 수 있는 해시 함수 자동 생성


### 36. 재구조 분해 선언
> 함수에서 하나 이상의 아이템을 반환하고 싶을 때

Pair 클래스 사용하면 됨
- 표준 라이브러리에 정의됨
- 구조 분해 (destructuring) : 여러 식별자를 동시에 선언하면서 초기화
  - ex : val (a,b,c) = Triple(1,2,3)

데이터 클래스는 자동으로 destructuring을 지원한다
```kotlin
val (value, description) = evaluate(7)
```
과 같이 사용 가능함. 이때 data class 생성자의 프로퍼티 **나열 순서대로** 값이 대입된다.
'_'를 사용해 필요하지 않은 프로퍼티를 생략 가능하다


### 37. Null이 될 수 있는 타입
> 경우에 따라 결과가 없는 함수가 있을 수 있다.
예를 들어, Map.get(key: T)의 경우 오류를 발생시키지 않으며 null을 반환한다.

코틀린에서 기본적으로 모든 타입은 non-nullable 하다.
하지만 무언가 null 결과를 내놓을 수 있다면, 타입 뒤에 '?'를 붙여서 결과가 null이 될 수 있음을 표시해야 한다.
이때, '?'를 붙이면 다른 타입이 되므로, 코틀린은 컴파일 시점에서 널이 될 수 없는 타입의 값은 결코 null이 되지 못하도록 도와준다.

- 자바는 대부분의 값이 Nullable하기 때문에, null인지 검사해주는 코드를 작성해야 한다.
- 코틀린에서는 null이 될 수 있는 타입을 단순히 역참조 (dereference), 즉, 멤버 프로퍼티나 함수에 접근할 수 없다.
  - 객체에 접근하기 위해서는 메모리에서 객체를 가져와야 함.


### 38. 엘비스 연산자
> 널 가능성 처리하기

Nullable한 타입을 참조하면 컴파일 오류가 발생한다. 안전한 호출이란, 일반 호출에 사용하는 `.`을 `?.`으로 바꾼 것이다. `?.`는 수신 객체가 null이 아닐 때만 연산을 수행한다.

**Elvis 연산자 `?:`**
- ?:의 왼쪽 식의 값이 null이 아니면 왼쪽 값이 결괏값이 된다. null이면 오른쪽 식의 값이 전체 결괏값이 된다

```kotlin
val length2 = s?.length ?: 0
```
위 코드와 같이 안전한 호출 다음에 엘비스 연산자를 사용해보자

### 39. Non-null assertion : 널 아님 단언
> 어떤 참조가 null이 될 수 없다는 사실을 특별히 알 수 있는 경우

`!!.` : 어떤 객체가 null이 아님을 단언함
되도록 사용하지 않고 안전한 호출이나 명시적 검사를 활용하는 쪽을 권장함.

사용할 때 1. 자바와 상호작용하는 경우 2. 코틀린이 검사 제대로 못할 경우

코드에서 `!!.`를 사용했다면, 이 문제를 언급하는 적절한 단언과 함께 함수를 분리하는 것이 좋다.
예를 들어, Map에 특정 키가 꼭 존재해야 할 경우 예외가 발생하는 편이 좋다고 가정하자. 이때 map[key]로 읽는 대신 getValue()를 사용하면 NoSuchElementException이 발생한다.


### 40. 확장 함수와 Nullable한 타입

String.isNullOrEmpty() 의 경우, 문자열이 null이여도 안전한 호출을 사용하지 않는다. 왜냐하면 String? 의 확장함수로 정의되어 있기 때문이다.

Nullable한 타입의 확장함수를 정의할 때 주의하기
- isNullOrEmpty와 같이 단순하고, 이름에서 수신 객체가 null일 수 있음을 암시하는 경우에는 유용함
- 하지만 일반적으로 Non-Nullable 확장을 정의하는 편이 낫다.
- 널 가능성을 감추고 코드를 읽는 독자를 혼란스럽게 할 수 있기 때문


### 41. 제네릭스
> 제네릭스는 파라미터화한 타입을 만든다
List, Set, Map같은 컬렉션 클래스를 만드는 것을 동기로 도입됨

**제네릭 클래스**
`class GenericHolder<T>{ .. }`

**제네릭 함수**
`fun <T> identity(arg: T): T`

**제네릭 확장 함수**
수신 객체 앞에 제네릭 명세를 위치
```kotlin
fun <T> List<T>.first(): T{
  if(isEmpty()) throw NoSuchElementException("Empty List")
  return this[0]
}
```

### 42. 확장 프로퍼티
확장 프로퍼티의 수신 객체 타입 또한 확장 함수와 비슷함
```kotlin
Type.extensionProperty: PropType
  get() { ... }
```
위와 같이 확장 프로퍼티에는 커스텀 getter가 필요함. 접근할 때마다 값이 계산된다.

하지만 28 내용을 참고해 프로퍼티와 함수 중 하나를 선택하라면,함수를 선택하자.
기능이 단순하고 가독성을 향상시키는 경우에만 프로퍼티를 권장함

재네릭의 확장 프로퍼티를 정의 가능하다.
**star projection**: 제네릭 인자 타입을 사용하지 않으면 *로 대체하자. 
  ex\) List<*>.indices의 경우 List에 담긴 원소의 타입 정보를 잃어버려서, Any?에만 대입 가능하다.


### 43. break와 continue
실전 코틀린 코드에서 break나 continue를 쓰는 일은 드물다. 코틀린이 더 나은 메커니즘을 제공하기 때문

**레이블**
단순히 break와 continue는 자신이 속한 범위보다 밖으로 점프할 수 없지만, 레이블을 사용하면 여러 루프의 경계 중 한군데로 점프 가능함

